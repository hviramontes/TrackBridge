<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Offline Map Preview</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Leaflet CSS -->
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        html, body, #map {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #map {
            width: 100%;
        }
        /* simple control panel styling */
        #layerControls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <!-- Layer toggles -->
    <div id="layerControls">
        <label><input type="checkbox" value="Ground" checked /> Ground</label><br />
        <label><input type="checkbox" value="Air" checked /> Air</label><br />
        <label><input type="checkbox" value="Sensor" checked /> Sensor</label><br />
        <label><input type="checkbox" value="Civilian" checked /> Civilian</label>
    </div>

    <div id="map"></div>

    <!-- Leaflet JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // 1️⃣ Helpers

        // read maxZoom param
        function getLocalMaxZoom() {
            const p = new URLSearchParams(window.location.search);
            const z = parseInt(p.get('localMaxZoom'));
            return isNaN(z) ? 0 : z;
        }

        // pick a color per track type
        function colorForType(type) {
            switch (type) {
                case 'Ground': return 'blue';
                case 'Air': return 'red';
                case 'Sensor': return 'orange';
                case 'Civilian': return 'green';
                default: return 'gray';
            }
        }

        // 2️⃣ Map setup
        const maxZoom = getLocalMaxZoom();
        const map = L.map('map', {
            minZoom: 0,
            maxZoom: maxZoom,
            center: [0, 0],
            zoom: 0,
            zoomControl: false
        });
        L.control.zoom({ position: 'topright' }).addTo(map);
        L.tileLayer('https://appassets/tiles/{z}/{x}/{y}.png', {
            minZoom, maxZoom, errorTileUrl: ''
        }).addTo(map);

        // storage
        const markers = {};
        const layers = { Ground: [], Air: [], Sensor: [], Civilian: [] };

        // 3️⃣ Main update function — called from WPF via ExecuteScriptAsync
        window.addOrUpdateMarker = function (data) {
            // remove old
            if (markers[data.id]) {
                map.removeLayer(markers[data.id]);
                const oldType = markers[data.id].options.trackType;
                layers[oldType] = layers[oldType].filter(m => m !== markers[data.id]);
            }

            // create circleMarker color-coded
            const marker = L.circleMarker([data.lat, data.lon], {
                radius: 8,
                color: colorForType(data.type),
                weight: 2,
                fillOpacity: 0.8,
                trackType: data.type,
                timestamp: data.timestamp
            }).addTo(map);

            marker.bindTooltip(data.label, { permanent: true, direction: 'right' });
            marker.on('click', () => {
                const html =
                    `ID: ${data.id}<br>` +
                    `Marking: ${data.label}<br>` +
                    `Lat: ${data.lat}<br>` +
                    `Lon: ${data.lon}`;
                marker.bindPopup(html).openPopup();
            });

            layers[data.type].push(marker);
            markers[data.id] = marker;

            // auto-zoom to include all current markers
            const positions = Object.values(markers).map(m => m.getLatLng());
            if (positions.length) {
                map.fitBounds(L.latLngBounds(positions), { padding: [20, 20] });
            }
        };

        // 4️⃣ Stale-marker cleanup every 5s
        setInterval(() => {
            const now = Date.now();
            for (const id in markers) {
                const m = markers[id];
                if (now - m.options.timestamp > 30000) { // older than 30s
                    map.removeLayer(m);
                    layers[m.options.trackType] =
                        layers[m.options.trackType].filter(x => x !== m);
                    delete markers[id];
                }
            }
        }, 5000);

        // 5️⃣ Layer toggles
        window.toggleLayer = function (type, visible) {
            layers[type].forEach(m => {
                visible ? map.addLayer(m) : map.removeLayer(m);
            });
        };
        document.querySelectorAll('#layerControls input[type=checkbox]')
            .forEach(cb => cb.addEventListener('change', function () {
                window.toggleLayer(this.value, this.checked);
            }));
    </script>
</body>
</html>
