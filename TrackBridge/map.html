<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <title>Offline Map Preview</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Leaflet CSS -->
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <!-- Leaflet.Draw CSS -->
    <link rel="stylesheet"
          href="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.css" />

    <style>
        html, body, #map {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        #map {
            width: 100%;
        }

        #layerControls {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 1000;
            background: white;
            padding: 5px;
            border-radius: 4px;
        }
    </style>
</head>
<body>

    <!-- Layer toggles -->
    <div id="layerControls">
        <label><input type="checkbox" value="Ground" checked /> Ground</label><br />
        <label><input type="checkbox" value="Air" checked /> Air</label><br />
        <label><input type="checkbox" value="Sensor" checked /> Sensor</label><br />
        <label><input type="checkbox" value="Civilian" checked /> Civilian</label>
    </div>

    <div id="map"></div>

    <!-- Leaflet & Draw JS -->
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-draw@1.0.4/dist/leaflet.draw.js"></script>
    <script>
        // ─── Helpers ─────────────────────────────────────────────────────────────────
        function getLocalMaxZoom() {
            const p = new URLSearchParams(window.location.search);
            const z = parseInt(p.get('localMaxZoom'));
            return isNaN(z) ? 0 : z;
        }
        function colorForType(type) {
            switch (type) {
                case 'Ground': return 'blue';
                case 'Air': return 'red';
                case 'Sensor': return 'orange';
                case 'Civilian': return 'green';
                default: return 'gray';
            }
        }

        // ─── Initialize Map ────────────────────────────────────────────────────────────
        const maxZoom = getLocalMaxZoom();
        const map = L.map('map', {
            minZoom: 0,
            maxZoom: maxZoom,
            center: [0, 0],
            zoom: 0,
            zoomControl: false
        });
        L.control.zoom({ position: 'topright' }).addTo(map);

        // load your local tiles from the virtual host at appassets
        L.tileLayer('https://appassets/tiles/{z}/{x}/{y}.png', {
            minZoom: 0,
            maxZoom: maxZoom,       // Leaflet’s overall cap
            maxNativeZoom: maxZoom, // don’t go past real tile data
            errorTileUrl: ''        // hide missing-tile errors
        }).addTo(map);

        // Clamp zoom if Leaflet over-zooms beyond available tiles
        map.on('zoomend', () => {
            if (map.getZoom() > maxZoom) {
                map.setZoom(maxZoom);
            }
        });

        // ─── Marker Storage ───────────────────────────────────────────────────────────
        const markers = {};
        const layers = { Ground: [], Air: [], Sensor: [], Civilian: [] };

        window.addOrUpdateMarker = function (data) {
            // remove old
            if (markers[data.id]) {
                map.removeLayer(markers[data.id]);
                const old = markers[data.id].options.trackType;
                layers[old] = layers[old].filter(m => m !== markers[data.id]);
            }

            // draw a circleMarker
            const m = L.circleMarker([data.lat, data.lon], {
                radius: 8,
                color: colorForType(data.type),
                weight: 2,
                fillOpacity: 0.8,
                trackType: data.type,
                timestamp: data.timestamp
            }).addTo(map);

            m.bindTooltip(data.label, { permanent: true, direction: 'right' });
            m.on('click', () => {
                m.bindPopup(
                    `ID: ${data.id}<br>` +
                    `Marking: ${data.label}<br>` +
                    `Lat: ${data.lat}<br>` +
                    `Lon: ${data.lon}`
                ).openPopup();
            });

            layers[data.type].push(m);
            markers[data.id] = m;

            // auto-zoom to show all markers, but don’t exceed maxZoom
            const pts = Object.values(markers).map(x => x.getLatLng());
            if (pts.length) {
                map.fitBounds(L.latLngBounds(pts), {
                    padding: [20, 20],
                    maxZoom: maxZoom
                });
            }
        };

        // cleanup stale markers
        setInterval(() => {
            const now = Date.now();
            for (let id in markers) {
                const m = markers[id];
                if (now - m.options.timestamp > 30000) {
                    map.removeLayer(m);
                    layers[m.options.trackType] =
                        layers[m.options.trackType].filter(x => x !== m);
                    delete markers[id];
                }
            }
        }, 5000);

        // layer toggles
        document.querySelectorAll('#layerControls input[type=checkbox]')
            .forEach(cb => cb.addEventListener('change', function () {
                layers[this.value].forEach(m => {
                    this.checked ? map.addLayer(m) : map.removeLayer(m);
                });
            }));

        // ─── Leaflet.Draw Setup ───────────────────────────────────────────────────────
        const drawLayer = new L.FeatureGroup();
        map.addLayer(drawLayer);

        const drawControl = new L.Control.Draw({
            draw: {
                polyline: false,
                polygon: false,
                circle: false,
                marker: false,
                rectangle: {
                    shapeOptions: { color: 'blue' }
                }
            },
            edit: { featureGroup: drawLayer }
        });
        map.addControl(drawControl);

        let lastBounds = null;
        map.on(L.Draw.Event.CREATED, e => {
            drawLayer.clearLayers();
            const layer = e.layer;
            drawLayer.addLayer(layer);
            lastBounds = layer.getBounds();

            window.chrome.webview.postMessage(JSON.stringify({
                type: 'download-rectangle',
                bounds: {
                    sw: lastBounds.getSouthWest(),
                    ne: lastBounds.getNorthEast()
                }
            }));
        });

        window.clearRectangle = () => {
            drawLayer.clearLayers();
            lastBounds = null;
        };
    </script>
</body>
</html>
